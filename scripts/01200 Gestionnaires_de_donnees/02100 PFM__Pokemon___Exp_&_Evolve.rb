module PFM
  class Pokemon
    # Return the base experience of the Pokemon
    # @return [Integer]
    def base_exp
      return $game_data_pokemon[@sub_id ? @sub_id : @id][@form].base_exp
    end
    # Return the exp curve type ID
    # @return [Integer]
    def exp_type
      return $game_data_pokemon[@sub_id ? @sub_id : @id][@form].exp_type
    end
    # Return the exp curve
    # @return [Array<Integer>]
    def exp_list
      return GameData::EXP_TABLE[exp_type]
    end
    # Return the required exp to increase the Pokemon's level
    # @return [Integer]
    def exp_lvl
      data = GameData::EXP_TABLE[exp_type]
      v = data[@level + 1]
      return data[@level] unless v
      return v
    end
    # Return the text of the amount of exp the pokemon needs to go to the next level
    # @return [String]
    def exp_remaining_text
      expa = self.exp_lvl - self.exp
      expa = 0 if expa < 0
      return expa.to_s
    end
    # Return the text of the current pokemon experience
    # @return [String]
    def exp_text
      "#@exp"
    end
    # Change the Pokemon total exp
    # @param v [Integer] the new exp value
    def exp=(v)
      @exp = v.to_i
      _exp_lvl = self.exp_lvl
      if(_exp_lvl >= @exp)
        _exp_last = GameData::EXP_TABLE[exp_type][@level]
        delta = _exp_lvl - _exp_last
        current = exp - _exp_last
        @exp_rate = (delta == 0 ? 1 : current / delta.to_f) #> Vérifier pour la correction
      else
        @exp_rate = (@level < GameData::MAX_LEVEL ? 1 : 0)
      end
    end
    # Increase the level of the Pokemon
    # @return [Boolean] if the level has successfully been increased
    def level_up
      return false if @level >= GameData::MAX_LEVEL
      _exp_last = GameData::EXP_TABLE[exp_type][@level]
      delta = self.exp_lvl - _exp_last
      self.exp += (delta - (exp - _exp_last))
      return true
    end
    # Generate the level up stat list for the level up window
    # @return [Array<Array<Integer>>] list0, list1 : old, new basis value
    def level_up_stat_refresh
      st=$game_temp.in_battle
      $game_temp.in_battle=false
      list0=[self.max_hp, self.atk_basis, self.dfe_basis, self.ats_basis, self.dfs_basis, self.spd_basis]
      @level += 1 if @level < GameData::MAX_LEVEL
      self.exp = exp_list[@level] if @exp<exp_list[@level].to_i
      hp_diff = list0[0] - @hp
      list1=[self.max_hp, self.atk_basis, self.dfe_basis, self.ats_basis, self.dfs_basis, self.spd_basis]
      self.hp = (self.max_hp-hp_diff) if @hp > 0
      $game_temp.in_battle=st
      return [list0, list1]
    end
    # Show the level up window
    # @param list0 [Array<Integer>] old basis stat list
    # @param list1 [Array<Integer>] new basis stat list
    # @param z_level [Integer] z superiority of the Window
    def level_up_window_call(list0, list1, z_level)
      window = Game_Window.new
      window.z = z_level
      window.width, window.height = 176, 192
      window.x = 320 - window.width
      window.windowskin = RPG::Cache.windowskin("M_1")
      sprite = Sprite.new(window.text_viewport).set_bitmap(sbmp = self.icon)
        .set_position(window.x + window.ox, window.y + window.oy)
      start_y = sbmp.height
      w = sbmp.width
      width = 110
      #window.add_text(w, 0, width - w, start_y, self.given_name, 1)
      i = 0
      format = "%d (+%d)"
      5.times do |i|
        start_y += 32
        window.add_text(16, start_y-48, width, 16, ::GameData::Text.get(22, 122 + i), 2)
        window.add_text(16, start_y-48+16, width, 16, sprintf(format, list1[i], list1[i]-list0[i]), 2)
      end
      Graphics.sort_z
      until Input.trigger?(:A)
        Graphics.update
      end
      $game_system.se_play($data_system.decision_se)
      window.dispose
      window = nil
      sprite.dispose unless sprite.disposed?
    end
    # Change the level of the Pokemon
    # @param lvl [Integer] the new level of the Pokemon
    def level=(lvl)
      if(lvl>0 and lvl<=GameData::MAX_LEVEL)
        @exp=self.exp_list[lvl]
        @exp_rate = 0
        @level=lvl
        
      end
    end
    # Check if the Pokemon can evolve and return the evolve id if possible
    # @param reason [Symbol] evolve check reason (:level_up, :trade, :stone)
    # @param extend_data [Hash, nil] extend_data generated by an item
    # @return [Integer, false] if the Pokemon can evolve, the evolve id, otherwise false
    def evolve_check(reason = :level_up, extend_data = nil)
      return false if @item_holding == 229#>Pierre Stase
      data = $game_data_pokemon[@id][0]
      if(reason == :level_up and data.evolution_level and data.evolution_level <= @level and data.evolution_id and data.evolution_id != 0)
        return data.evolution_id
      end
      return false unless data.special_evolution
      stone = (reason == :stone)
      data.special_evolution.each do |e|
        #>Prévention des pierres
        next if stone and !e[:stone]
        #>Echanger contre
        next if(e[:trade_with] and e[:trade_with] != extend_data)
        #>Niveau minimum
        next if(e[:min_level] and e[:min_level] > @level)
        #>Niveau maximum
        next if(e[:max_level] and e[:max_level] < @level)
        #>En portant un objet
        next if(e[:item_hold] and e[:item_hold] != @item_holding)
        #>Bonheur min
        next if(e[:min_loyalty] and e[:min_loyalty] > @loyalty)
        #>Bonheur max
        next if(e[:max_loyalty] and e[:max_loyalty] < @loyalty)
        #>Les attaques
        if(e[:skill_1])
          next unless skill_learnt?(e[:skill_1])
          if(e[:skill_2])
            next unless skill_learnt?(e[:skill_2])
            if(e[:skill_3])
              next unless skill_learnt?(e[:skill_3])
              if(e[:skill_4])
                next unless skill_learnt?(e[:skill_4])
              end
            end
          end
        end
        #>Météo spécifique
        next if(e[:weather] and $env.weather != e[:weather])
        #>Être sur un tag
        next if(e[:env] and $game_player.system_tag != e[:env])
        #>Un genre spécifique
        next if(e[:gender] and @gender != e[:gender])
        #>Application d'une pierrre
        next if(e[:stone] and e[:stone] != extend_data)
        #>Moment de la journée
        next if(e[:day_night] and e[:day_night] != $game_variables[::Yuki::Var::TJN_Tone])
        #>Appel de fonction
        next if(e[:func] and !self.send(*e[:func]))
        #>Sur des maps
        next if(e[:maps] and !e[:maps].include?($game_map.map_id))
        if(reason == :trade)
          return e[:trade] if e[:trade]
        else
          return e[:id] if e[:id]
        end
      end
      return false
    end
    # Change the id of the Pokemon
    # @param v [Integer] the new id of the Pokemon
    def id=(v)
      @character = nil
      if($game_data_pokemon[v])
        @id = v
        @form = 0 unless $game_data_pokemon[v][@form]
        @form = _form_generation(@id, -1) if @form == 0
        @form = 0 unless $game_data_pokemon[v][@form]
      end
    end
    # Check evolve condition to evolve in Hitmonlee (kicklee)
    # @return [Boolean] if the condition is valid
    def elv_kicklee
      self.atk > self.dfe
    end
    # Check evolve condition to evolve in Hitmonchan (tygnon)
    # @return [Boolean] if the condition is valid
    def elv_tygnon
      self.atk < self.dfe
    end
    # Check evolve condition to evolve in Hitmontop (Kapoera)
    # @return [Boolean] if the condition is valid
    def elv_kapoera
      self.atk == self.dfe
    end
    # Check evolve condition to evolve in Silcoon (Armulys)
    # @return [Boolean] if the condition is valid
    def elv_armulys
      ((@code & 0xFFFF) % 10) <= 4
    end
    # Check evolve condition to evolve in Cascoon (Blindalys)
    # @return [Boolean] if the condition is valid
    def elv_blindalys
      !self.elv_armulys
    end
    # Check evolve condition to evolve in Mantine (Démanta)
    # @return [Boolean] if the condition is valid
    def elv_demanta
      $pokemon_party.has_pokemon?(223)
    end
    # Check evolve condition to evolve in Pangoro (Pandarbare)
    # @return [Boolean] if the condition is valid
    def elv_pandarbare
      $actors.each do |i|
        return true if i and i.type_dark?
      end
      return false
    end
    # Check evolve condition to evolve in Malamar (Sepiatroce)
    # @note uses :DOWN to validate the evolve condition
    # @return [Boolean] if the condition is valid
    def elv_sepiatroce
      return Input.press?(:DOWN)
    end
    # Check evolve condition to evolve in Sylveon (Nymphali)
    # @return [Boolean] if the condition is valid
    def elv_nymphali
      @skills_set.each do |skill|
        return true if skill and skill.type_fairy?
      end
      return false
    end
  end
end